from __future__ import annotations
from typing import Sequence
from enum import Enum

from ferdelance.logging import get_logger
from ferdelance.core.distributions import Collect
from ferdelance.core.interfaces import Step
from ferdelance.core.model import Model
from ferdelance.core.model_operations import Train
from ferdelance.core.operations import Aggregation
from ferdelance.core.steps import Finalize, Parallel

from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from sklearn.preprocessing import LabelEncoder

from numpy.typing import ArrayLike

import numpy as np

LOGGER = get_logger(__name__)


class StrategyRandomForestClassifier(str, Enum):
    MERGE = "merge"
    """The trees generated by all clients will be merged in a single RandomForestClassifier"""

    MAJORITY_VOTE = "majority_vote"
    """All the models will be put together and a classification is decided by majority vote between all models."""


class FederatedRandomForestClassifier(Model):
    """
    This class also defines all the parameters accepted in training by the model.

    These parameters are default values from scikit-learn.

    For more details, please refer to https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html
    """

    strategy: StrategyRandomForestClassifier = StrategyRandomForestClassifier.MERGE

    n_estimators: int = 100
    criterion: str = "gini"
    max_depth: int | None = None
    min_samples_split: int = 2
    min_samples_leaf: int = 1
    min_weight_fraction_leaf: float = 0
    max_features: str = "sqrt"
    max_leaf_nodes: int | None = None
    min_impurity_decrease: float = 0
    bootstrap: bool = True
    oob_score: bool = False
    n_jobs: int | None = None
    random_state: int | None = None
    class_weight: str | list[str] | list[dict[str, float]] | None = None
    ccp_alpha: float = 0
    max_samples: int | None = None

    def get_steps(self) -> Sequence[Step]:
        return [
            Parallel(
                Train(
                    query=self.query,
                    model=self,
                ),
                Collect(),
            ),
            Finalize(
                Aggregation(
                    model=self,
                ),
            ),
        ]

    def train(self, x, y) -> RandomForestClassifier:
        model = RandomForestClassifier(**self.dict())
        model.fit(x, y)
        return model

    def aggregate(
        self, model_a: RandomForestClassifier | VotingClassifier, model_b: RandomForestClassifier
    ) -> RandomForestClassifier | VotingClassifier:
        LOGGER.info(f"AggregatorRandomForestClassifier: using strategy={self.strategy}")

        if self.strategy == StrategyRandomForestClassifier.MERGE:
            if not isinstance(model_a, RandomForestClassifier):
                raise ValueError(
                    "StrategyRandomForestClassifier.MERGE can be used only with RandomForestClassifier models"
                )

            model = self.merge(model_a, model_b)

        elif self.strategy == StrategyRandomForestClassifier.MAJORITY_VOTE:
            model = self.majority_vote(model_a, model_b)

        else:
            raise ValueError(f"Unsupported strategy: {self.strategy}")

        return model

    def merge(self, model_a: RandomForestClassifier, model_b: RandomForestClassifier) -> RandomForestClassifier:
        """Solution adapted from: https://stackoverflow.com/a/28508619/1419058"""

        model_a.estimators_ += model_b.estimators_
        model_a.n_estimators = len(model_a.estimators_)  # type: ignore

        return model_a

    def majority_vote(
        self, model_a: RandomForestClassifier | VotingClassifier, model_b: RandomForestClassifier
    ) -> VotingClassifier:
        """Solution adapted from: https://stackoverflow.com/a/54610569/1419058"""

        if isinstance(model_a, VotingClassifier):
            assert model_a.estimators_ is not None

            models = []

            for i in range(len(model_a.estimators_)):
                models.append((f"{i}", model_a.estimators_[i]))

            models.append((f"{len(model_a.estimators_)}", model_b))

        else:
            models = [("0", model_a), ("1", model_b)]

        vc = VotingClassifier(estimators=models, voting="soft")

        vc.estimators_ = models
        vc.le_ = LabelEncoder().fit(model_a.classes_)  # TODO: check if this is valid?
        vc.classes_ = vc.le_.classes_

        return vc

    def predict(self, x) -> np.ndarray:
        if self.model is None:
            raise ValueError("No model has been loaded or created")
        return self.model.predict_proba(x)

    def classify(self, x) -> np.ndarray | ArrayLike:
        if self.model is None:
            raise ValueError("No model has been loaded or created")
        return self.model.predict(x)
